#include <cxxopts.hpp>

#include "lib/Compiler.hpp"
#include "lib/Log.hpp"

inline LibOrichalcum::CompilerOptions init_options(int argc, char *argv[]) {
	LibOrichalcum::CompilerOptions compiler_options;
	cxxopts::Options options("Orichalcum", "Orichalcum Standard Compiler v0.0.1");
	options
		.positional_help("[Positional args]")
		.show_positional_help();
	options.add_options()
		("f,file", "[Positional] File to use as input", cxxopts::value<std::string>())
		("debug-all", "Enables debug messages for all parts of the compiler. Generates A LOT of output.")
		("debug-lexer", "Prints debug info about tokens generated by the lexer.")
		("debug-vm", "Enables debug messages for the virtual machine.")
		("h,help", "Prints this help message")
	;

	compiler_options.print_output = true;
	options.parse_positional({"file"});
	auto result = options.parse(argc, argv);

	if (result.count("help")) {
		std::cout << options.help() << std::endl;
		exit(0);
	}

	if (result.count("debug-all")) {
		compiler_options.log_level = LibOrichalcum::LOG_LEVEL::DEBUG;
	}

	if (result.count("debug-lexer") || result.count("debug-all")) {
		compiler_options.debug_parser = true;
	}

	if (result.count("debug-vm") || result.count("debug-all")) {
		compiler_options.debug_vm = true;
	}

	if (result.count("file")) {
		compiler_options.file = result["file"].as<std::string>();
	} else {
		LibOrichalcum::Log::set_level(LibOrichalcum::LOG_LEVEL::ERROR_, true);
		LibOrichalcum::Log::error("Need a file to compile.");
		exit(1);
	}

	return compiler_options;
}

int main(int argc, char *argv[]) {
	LibOrichalcum::CompilerOptions compiler_options = init_options(argc, argv);
	LibOrichalcum::Compiler compiler(compiler_options);
	auto result = compiler.run();

	return 0;
}
